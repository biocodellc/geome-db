buildscript {
    repositories {
        mavenCentral()
        jcenter()
    }
    dependencies {
        classpath "org.ajoberstar:gradle-git:1.4.2"
        classpath "com.github.marceloemanoel:gradle-environments-plugin:0.1"
        classpath "org.hidetake:gradle-ssh-plugin:2.0.0"
    }
}

plugins {
    id 'com.gradle.build-scan' version '1.3'
    id 'org.hidetake.ssh' version '1.6.0'
    id "com.eriwen.gradle.js" version "2.14.1"
}


import com.eriwen.gradle.js.tasks.MinifyJsTask
import org.ajoberstar.grgit.*
import groovy.io.FileType
import groovy.json.*

apply plugin: "java"
apply plugin: "application"
apply plugin: "war"
apply plugin: "idea"
apply plugin: "environments"
apply plugin: "org.hidetake.ssh"
apply plugin: "com.eriwen.gradle.js"

targetCompatibility = 1.8
sourceCompatibility = 1.8

repositories {
    mavenCentral()
}

buildScan {
    licenseAgreementUrl = 'https://gradle.com/terms-of-service'
    licenseAgree = 'yes'
}

//noinspection GroovyAssignabilityCheck
configurations {
    provided
    server
}

idea {
    module {
        scopes.COMPILE.plus += [configurations.server]
        scopes.PROVIDED.plus += [configurations.provided]
    }
}

// this is necessary for the fatWar task subprojects.each closure to work correctly
subprojects.each { subproject -> evaluationDependsOn(subproject.path) }

//noinspection GroovyAssignabilityCheck
sourceSets {
    main {
        compileClasspath += [configurations.server]
        compileClasspath += [configurations.provided]
    }
    test {
        compileClasspath += [configurations.server]
        runtimeClasspath += [configurations.server]
    }
}

dependencies {
    server('org.glassfish.jersey.ext:jersey-spring3:2.25') {
        exclude module: 'bean-validator'
        exclude module: 'asm-all-repackaged'
    }
    server 'org.glassfish.jersey.media:jersey-media-multipart:2.25'

    server 'com.fasterxml.jackson.datatype:jackson-datatype-hibernate5:2.8.4'
    server 'org.springframework.data:spring-data-jpa:1.10.1.RELEASE'
    server group: 'org.hibernate.javax.persistence', name: 'hibernate-jpa-2.1-api', version: '1.0.0.Final'

    server 'javax.servlet:servlet-api:2.4'
    server 'org.slf4j:slf4j-log4j12:1.7.19'
    server 'com.googlecode.json-simple:json-simple:1.1.1'

    server 'org.apache.commons:commons-digester3:3.2'
    server 'commons-cli:commons-cli:1.2'
    server group: 'org.apache.commons', name: 'commons-exec', version: '1.3'

    server group: 'org.apache.commons', name: 'commons-io', version: '1.3.2'

    provided 'org.eclipse.jetty:jetty-servlet:9.3.3.v20150827'

    compile project(":biocode-fims-commons")
    compile project(":biocode-fims-sequences")

    testCompile "junit:junit-dep:4.10"
}

distributions {
    main {
        contents {
            into('lib') {
                from configurations.server
            }
        }
    }
}

// specify files that require a specific loading order
ext.externLibsOrdered = ["${projectDir}/src/main/web/js/externalLibs/lodash.js", "${projectDir}/src/main/web/js/externalLibs/papaparse.min.js",
                         "${projectDir}/src/main/web/js/externalLibs/xlsx.min.js", "${projectDir}/src/main/web/js/externalLibs/xlsx-reader.js"]
javascript.source {
    externLibs {
        js {
            srcDir "src/main/web/js/externalLibs"
            include "*.js"
            // exclude any file that is in the externLibsOrdered list
            exclude {
                it.file in files(externLibsOrdered).files
            }
        }
    }
    app {
        js {
            srcDir "src/main/web/app"
            include "**/*.js"
            exclude "app.js"
            exclude "app.module.js"
            exclude "**/module.js"
        }
    }
    js {
        js {
            srcDir "src/main/web/js"
            include "*.js"
        }
    }
    modules {
        js {
            srcDir "src/main/web/app"
            include "**/module.js"
        }
    }
}


webAppDirName = "src/main/web"
libsDirName = "../dist"

mainClassName = "biocode.fims.dipnet.run.DipnetFusekiToESMigrator"
project.ext.environment = project.hasProperty('environment') ? project.getProperty('environment') : defaultEnvironment

//noinspection GroovyAssignabilityCheck
clean {
    delete libsDir
}

// jetty ssh plugin
remotes {
    biscicol {
        host = 'biscicol.org'
        user = biscicolUser
        password = biscicolPassword
    }
}

allprojects {
    task verifyMasterBranch(overwrite: true) << {
        ext.repo = Grgit.open(project.file('.'))
        if (ext.repo.branch.current.name != "master")
            throw new GradleScriptException(project.name + ' is not on the master branch', null)
    }
}

war {
    // add minifies and concatinated js files
    webInf {
        from "${buildDir}/js"
        into "/js/"
    }
}

startScripts {
    subprojects.each { subproject ->
        project.configurations.server.dependencies.addAll(subproject.configurations.server.dependencies)
    }

    classpath = files(jar.archivePath, configurations.server, configurations.runtime)
}

task setProductionEnv << {
    project.ext.environment = "production"
}
task setDevelopmentEnv << {
    project.ext.environment = "development"
}
task setLocalEnv << {
    project.ext.environment = "local"
}

// if setProductionEnv or setDevelopmentEnv is run, make sure this is done before processResources
setProductionEnv.mustRunAfter compileJava
setDevelopmentEnv.mustRunAfter compileJava
setLocalEnv.mustRunAfter compileJava

/*
Delete any resource files in src/main/resources if the file exists in a sub directory
of src/main/environment, excluding the current environment setting directory
*/
task cleanResourceDirectory {
    doLast {
        def allResourceFilesToRemove = []

        def environmentDir = new File("src/main/environment")
        environmentDir.eachFileRecurse(FileType.FILES) { file ->
            allResourceFilesToRemove << file.name
        }

        allResourceFilesToRemove.each {
            def resourceFile = new File("src/main/resources/${it}")
            if (resourceFile.exists()) {
                resourceFile.delete()
            }
        }
    }
}

task copyEnvironmentResources {
    dependsOn cleanResourceDirectory
    doLast {
        project.copy {
            from "src/main/environment/${project.environment}"
            into "src/main/resources"
            include "**/*"
            exclude "web.xml"
            exclude ".gitkeep"
        }
    }
}
processResources.dependsOn copyEnvironmentResources

task copyWebXml {
    inputs.dir "src/main/environment/${project.environment}/web.xml"
    outputs.dir "src/main/web/WEB-INF"
    doLast {
        project.copy {
            from "src/main/environment/${project.environment}"
            into "src/main/web/WEB-INF"
            include "web.xml"
        }
    }
}

processResources.dependsOn copyWebXml

task restartFims {
    group = 'biscicol.org'
    description = 'Restart biscicol.org production jetty instance'
    doLast {
        ssh.run {
            session(remotes.biscicol) {
                executeSudo biscicolJettyPath + ' restart'
            }
        }
    }
}

task restartFimsDev {
    group = 'biscicol.org'
    description = 'Restart biscicol.org dev jetty instance'
    doLast {
        ssh.run {
            session(remotes.biscicol) {
                executeSudo biscicolJettyDevPath + ' restart'
            }
        }
    }
}

ext.updateRemoteDependencies = { location ->
    subprojects.each { subproject ->
        project.configurations.server.dependencies.addAll(subproject.configurations.server.dependencies)
    }

    ssh.run {
        session(remotes.biscicol) {
            execute "/bin/rm -f " + location + "*"
            put from: project.configurations.server.incoming.getFiles(), into: location
        }
    }
}

task updateDependenciesDev {
    group = "biscicol.org"
    description = "update the jars located in " + remoteDevLibsDirectory

    doLast {
        updateRemoteDependencies(remoteDevLibsDirectory)
    }
}

task updateDependencies {
    group = "biscicol.org"
    description = "update the jars located in " + remoteLibsDirectory

    dependsOn verifyMasterBranch

    doLast {
        updateRemoteDependencies(remoteLibsDirectory)
    }
}

ext.remoteDeploy = { workingDir, remoteLibsDir, remoteWarDir ->
    ssh.run {
        session(remotes.biscicol) {
            // Cleanup to begin
            execute "/bin/rm -rf " + workingDir
            execute "/bin/mkdir " + workingDir
            // Copy war file to server
            put from: war.archivePath.path, into: workingDir
            // Extract libs and copy from server
            execute "/usr/bin/unzip -d " + workingDir + " " + workingDir + war.archiveName
            execute "/bin/cp " + remoteLibsDir + "* " + workingDir + "WEB-INF/lib/"
            // Remove the old war file
            execute "/bin/rm " + workingDir + war.archiveName
            // Need to remove the war file itself-- we instead just copy it into /tmp for safekeeping in case next step fails
            execute "/bin/mv " + remoteWarDir + "dipnet.war" + " /tmp/dipnet.deployed.war.backup"
            // Need to execute zip command from the working Directory in order to get relative paths correct
            execute "cd " + workingDir + ";/usr/bin/zip -r " + remoteWarDir + "dipnet.war " + " ."
            // Cleanup
            execute "/bin/rm -rf " + workingDir
            execute "/bin/rm /tmp/dipnet.deployed.war.backup"
        }
    }
}

task deployFims {
    group = 'biscicol.org'
    description = 'verify that all subprojects are on the master branch. Then build and copy war to biscicol.org production jetty webApp directory'

    dependsOn verifyMasterBranch
    dependsOn setProductionEnv
    dependsOn war

    doLast {
        def workingDir = "/tmp/dipnetProd/"
        remoteDeploy(workingDir, remoteLibsDirectory, remoteWarDirectory)
    }
}

task deployFimsDev {
    group = 'biscicol.org'
    description = 'build and copy war to biscicol.org development jetty webApp directory'

    dependsOn setDevelopmentEnv
    dependsOn war

    doLast {
        def workingDir = "/tmp/dipnetDev/"
        remoteDeploy(workingDir, remoteDevLibsDirectory, remoteWarDevDirectory)

    }
}

task fatWar(type: War) {
    archiveName = "dipnet-fims-fat.war"

    subprojects.each { subproject ->
        project.configurations.server.dependencies.addAll(subproject.configurations.server.dependencies)
    }

    classpath configurations.server
    classpath configurations.compile

    // exclude the src/main/web/app & src/main/web/js dirs. These files are concatenated and minified in the minifyJs task
    // and added in the webInf closure
    exclude("app/**/*.js")
    exclude("js")
    webInf {
        from "${buildDir}/js"
        into "/js/"
    }
}

task deployFimsLocal {
    description = 'local dipnet fims deployment'

    dependsOn setLocalEnv
    dependsOn fatWar

    doLast {
        project.copy {
            from fatWar.destinationDir
            into localWarDirectory
            include fatWar.archiveName
            rename fatWar.archiveName, "dipnet.war"
        }
    }
}

combineJs {
    encoding = "UTF-8"
    source = files("src/main/web/app/app.module.js", javascript.source.modules.js.files, javascript.source.app.js.files, javascript.source.js.js.files)
    dest = file("src/main/web/js/all.js")
}

task jsExternalLibs(type: MinifyJsTask) {
    source = externLibsOrdered + javascript.source.externLibs.js.files
    dest = file("${buildDir}/js/allExternalLibs.min.js")
    sourceMap = file("${buildDir}/js/allExternalLibs.min.map")
    closure {
        warningLevel = 'QUIET'
        compilerOptions.language = "ECMASCRIPT5"
    }

    doLast { task ->
        file(dest) << "\n//# sourceMappingURL=allExternalLibs.min.map"

        def sources = []

        task.source.files.each { file ->
            sources << ".." + file.canonicalPath.minus(projectDir.canonicalPath + "/" + webAppDirName)
        }

        Map srcMap = new JsonSlurper().parseText(sourceMap.text)
        srcMap.sources = sources
        sourceMap.withWriter("UTF-8") { it << new JsonBuilder(srcMap).toPrettyString() }
    }
}

task jsApp(type: MinifyJsTask) {
    source = files("src/main/web/app/app.module.js", javascript.source.modules.js.files, javascript.source.app.js.files, javascript.source.js.js.files)
    dest = file("${buildDir}/js/all.min.js")
    sourceMap = file("${buildDir}/js/all.min.map")
    closure {
        compilerOptions.language = "ECMASCRIPT5"
    }

    doLast { task ->
        file(dest) << "\n//# sourceMappingURL=all.min.map"

        def sources = []

        task.source.files.each { file ->
            sources << ".." + file.canonicalPath.minus(projectDir.canonicalPath + "/" + webAppDirName)
        }

        Map srcMap = new JsonSlurper().parseText(sourceMap.text)
        srcMap.sources = sources
        sourceMap.withWriter("UTF-8") { it << new JsonBuilder(srcMap).toPrettyString() }
    }
}

task minifyJs(overwrite: true) {
    dependsOn jsExternalLibs
    dependsOn jsApp
}

task copyEnvironmentFiles(overwrite: true) {
    dependsOn copyWebXml
    dependsOn copyEnvironmentResources
}

task addProdJsLibs(type: WebJsLibTask,
        description: 'Modify index.html to include the combined, minified, and compressed js files') {
    html = file('src/main/web' + '/index.html')
    environment = 'production'
}

task addDevJsLibs(type: WebJsLibTask,
        description: 'Modify the index.html to include all js files') {
    html = file('src/main/web/index.html')
    environment = 'local'
}

class WebJsLibTask extends DefaultTask {
    final def tag = "<!-- LIBRARY LOADING -->"
    final def endTag = "<!-- END: LIBRARY LOADING -->"

    @InputFile
    File html

    @Input
    String environment

    @OutputFile
    @Optional
    File outputHtml

    def environmentToInclude = ['local': DEV_INCLUDE, 'production': PROD_INCLUDE]

    final static def DEV_INCLUDE = """
<!-- USE individual js files FOR LOCAL DEV -->
<script src=\"libs/head/1.0.3/head.min.js\" data-headjs-load=\"js/init.js\"></script>
"""
    final static def PROD_INCLUDE = """
<!-- use minified and combined js file FOR PROD -->
<script src="js/allExternalLibs.min.js"></script>
<script src="js/all.min.js"></script>
"""

    @TaskAction
    def void applyScriptAndStylesheetTags() {
        if (html.exists()) {
            def htmlReplacement = html.getText().replaceAll(
                    "$tag\\p{all}*$endTag",
                    "$tag${getHtmlReplacement(environment)}$endTag")
            if (outputHtml == null) outputHtml = html
            outputHtml.setText(htmlReplacement, 'UTF-8')
        }
    }

    def String getHtmlReplacement(String environment) {
        switch (environment) {
            case 'local':
                return getLocalHtml()
            case 'production':
                return environmentToInclude['production']
        }
    }

    def String getLocalHtml() {
        String html = "\n"

        project.jsExternalLibs.source.files.each { file ->
            html += "<script src=\"" + file.canonicalPath.minus(project.projectDir.canonicalPath + "/" + project.webAppDirName + "/") + "\"></script>\n";
        }
        project.jsApp.source.files.each { file ->
            html += "<script src=\"" + file.canonicalPath.minus(project.projectDir.canonicalPath + "/" + project.webAppDirName + "/") + "\"></script>\n";
        }

        return html
    }
}

minifyJs.dependsOn addProdJsLibs
fatWar.dependsOn minifyJs
war.dependsOn minifyJs
